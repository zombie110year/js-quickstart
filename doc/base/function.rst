####
函数
####

.. highlight:: javascript

定义函数的两种方式
==================

首先, 是最正统的定义函数的方式::

    function functionName( parameter1, parameter2, ...) {
        // function body
        return x;
    }

在任何语言中, 都有几乎相同的语法,
因此不再赘述.

然后, 是定义匿名函数的方式::

    (arg1, arg2, arg3) => {
        // function body
    }

匿名函数没有名字, 但是, 它可以被赋值给一个标识符::

    add = (a, b) => {return a + b;}

那么, 这个标识符就可以当做函数使用了.

另外, 匿名函数甚至可以直接运行,
只要用括号将整个语法包裹起来::

    ( (a, b) => {return a + b;} )(1, 2);
    // 3

可以这么看待匿名函数:
    它是一个由 形参表 + ``=>`` + 函数体 构成的函数对象.

在编写匿名函数时, 最好只在函数体中写一两句长度的逻辑.
如果需要更长的表达, 最好单独编写一个普通函数.

JavaScript 的匿名函数和其他语言中有不一致的地方,
那就是: JavaScript 的匿名函数具有完整的函数特性.
普通函数能做到的, 匿名函数也能做到.

最明显的一点就是: js 的匿名函数可以写得很长.
然而, 匿名函数又可以嵌入在其他结构当中.
所以, 滥用匿名函数的 js 代码往往可读性极差.

(匿名函数由于使用了一个小箭头 ``=>``,
所以又被称为 "箭头函数")

arguments 与 rest 参数
======================

-   ``arguments`` 变量储存了所有传入的参数.
    是一个 :js:class:`Array` 类型的变量.
-   ``rest`` 变量储存了所有传入的参数中排除掉已在参数表中的参数的参数.
    同样是一个 Array

以上两个标识符只在函数体中起作用.

一般情况下, 它们都是用于修改参数的性质,
例如, 通过检查 arguments, rest 的内容,
来设定默认参数, 可选参数等.

作用域
======

在 js 当中, 一个 js 文件, 被称为一个模块,
模块作用域是最基础的作用域.
也称全局作用域.

在模块作用域下, 则是函数作用域.
在函数作用域(或模块作用域)下, 则是语句块作用域.
语句块是指 ``if``, ``while`` 等结构或者 ``{}`` 花括号下
的语句块. 这也会划分一个作用域.

而其他的对象,
则和普通的变量一样,
没有独立的作用域.

在 js 当中, 要生命一个变量,
可以在它前面使用 ``var``, ``let`` 或者什么也不加, 直接赋值.

直接赋值, 则无论该变量位于何处,
它将被保存在全局作用域之下.

而使用 var, 则保存在函数作用域中
如果该变量是在函数之外, 模块之中声明的,
那么它仍然处于全局作用域当中.

使用 let, 则对应语句块作用域啦.
与 var, 类似, 如果该变量是在语句块之外声明的,
它将处于函数或全局作用域中.

另外还有一个 const 关键字,
这个关键字将声明一个常量.

常量不可修改, 只可在声明的同时进行定义.

const 关键字在作用域方面和 let 一致.

声明提升
========

JavaScript 具有声明提升的特性.
就是说, 一个变量被使用时,
它的声明将会被提升至作用域的顶部.

不过, 被提升的仅仅是声明,
它的赋值操作仍然处于代码原位置.

例如::

    (() => {
        var x = y;
        var y = 1;
        console.log(x);
        console.log(y);
    })();

变量 x 在 y 的定义语句之前就使用了 y,
而 js 将 y 的声明提升了,
导致将 y 赋值给 x 时,
y 是一个值为 ``undefinied`` 的已声明的变量.

于是, 这个代码中, x = undefinied, y = 1.

可能你会以为 js 中任何未声明的变量都有 undefinied 值.
那么, 试试下面这个例子, y 从来没有声明过,
因此, 程序报错::

    (() => {
        var x = y;
        console.log(x);
        console.log(y);
    })();

    ReferenceError: y is not defined

包括变量在内, js 中的一切对象都具有声明提升的性质.
例如, 在一个函数中调用另一个函数,
无需将被调用函数定义在调用者之前, 或者在文件头部写上函数声明.

命名空间
========

js 的命名空间, 是用过 ``对象`` 来实现的.
js 中的一个对象, 可以绑定其他对象或函数到自身的一个属性名上.

全局作用域, 就是在一个命名为 ``window`` 的命名空间之中.

在 js 代码中, 任何可在全局使用的函数或变量,
都可以改名为 ``window.name`` 使用,
它们指向同样的对象.

如果所编写的 js 项目由很多模块组成,
那么为了避免同名对象覆盖,
可以在每个模块中建立一个独立的命名空间,
(实际上就是建立一个空的对象)::

    var namespace = {};

然后将所有全局变量与函数定义挂载到 namespace 当中.
(标识符 namespace 可以取一个具有意义的名字)::

    var app = {};
    app.run = function () { ... };
    const app.CONST = 12;

解构赋值
========

可以将一个数组或对象直接拆分掉赋值给多个变量::

    var [a, b, c] = Array(1, 2, 3)

    // a = 1
    // b = 2
    // c = 3

    var {name, width} = {name: "hello", width=100}

数组按位置排列, 对象则按命名将属性赋值给对应的变量.

如果有多余的变量, 那么没有得到值的变量将被赋值为 ``undefinied``.
其中, 拆分对象的时候, 可以为变量设置默认值或者修改标识符的命名::

    var {age=19} = {name: "hello"}
    // 变量 age 设置了默认值 19, 而后面的对象并没有 age 属性.
    var {name:id} = {name: "hello"}
    id == "hello"
    // 将对象的 name 属性赋值给变量 id

而对于数组, 则可通过留空位的方式忽略一些值::

    var [, , a] = Array(1, 2, 3)
